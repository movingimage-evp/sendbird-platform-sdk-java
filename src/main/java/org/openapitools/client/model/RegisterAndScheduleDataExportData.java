/*
 * Sendbird Platform SDK
 * Sendbird Platform API Javascript SDK  https://sendbird.com/docs/chat/v3/platform-api/getting-started/prepare-to-use-api
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.sendbird.client.JSON;

/**
 * RegisterAndScheduleDataExportData
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-07-21T17:39:57.479198+01:00[Europe/London]")
public class RegisterAndScheduleDataExportData {
  public static final String SERIALIZED_NAME_START_TS = "start_ts";
  @SerializedName(SERIALIZED_NAME_START_TS)
  private Integer startTs;

  public static final String SERIALIZED_NAME_END_TS = "end_ts";
  @SerializedName(SERIALIZED_NAME_END_TS)
  private Integer endTs;

  public static final String SERIALIZED_NAME_FORMAT = "format";
  @SerializedName(SERIALIZED_NAME_FORMAT)
  private String format;

  public static final String SERIALIZED_NAME_CSV_DELIMITER = "csv_delimiter";
  @SerializedName(SERIALIZED_NAME_CSV_DELIMITER)
  private String csvDelimiter;

  public static final String SERIALIZED_NAME_TIMEZONE = "timezone";
  @SerializedName(SERIALIZED_NAME_TIMEZONE)
  private String timezone;

  public static final String SERIALIZED_NAME_SENDER_IDS = "sender_ids";
  @SerializedName(SERIALIZED_NAME_SENDER_IDS)
  private List<Integer> senderIds = null;

  public static final String SERIALIZED_NAME_EXCLUDE_SENDER_IDS = "exclude_sender_ids";
  @SerializedName(SERIALIZED_NAME_EXCLUDE_SENDER_IDS)
  private List<Integer> excludeSenderIds = null;

  public static final String SERIALIZED_NAME_CHANNEL_URLS = "channel_urls";
  @SerializedName(SERIALIZED_NAME_CHANNEL_URLS)
  private List<String> channelUrls = null;

  public static final String SERIALIZED_NAME_EXCLUDE_CHANNEL_URLS = "exclude_channel_urls";
  @SerializedName(SERIALIZED_NAME_EXCLUDE_CHANNEL_URLS)
  private List<String> excludeChannelUrls = null;

  public static final String SERIALIZED_NAME_USER_IDS = "user_ids";
  @SerializedName(SERIALIZED_NAME_USER_IDS)
  private List<Integer> userIds = null;

  public static final String SERIALIZED_NAME_SHOW_READ_RECEIPT = "show_read_receipt";
  @SerializedName(SERIALIZED_NAME_SHOW_READ_RECEIPT)
  private Boolean showReadReceipt;

  public static final String SERIALIZED_NAME_SHOW_CHANNEL_METADATA = "show_channel_metadata";
  @SerializedName(SERIALIZED_NAME_SHOW_CHANNEL_METADATA)
  private Boolean showChannelMetadata;

  public static final String SERIALIZED_NAME_NEIGHBORING_MESSAGE_LIMIT = "neighboring_message_limit";
  @SerializedName(SERIALIZED_NAME_NEIGHBORING_MESSAGE_LIMIT)
  private Integer neighboringMessageLimit;

  public RegisterAndScheduleDataExportData() { 
  }

  public RegisterAndScheduleDataExportData startTs(Integer startTs) {
    
    this.startTs = startTs;
    return this;
  }

   /**
   * Specifies the starting timestamp of a period for target objects&#39; creation date, in [Unix milliseconds](/docs/chat/v3/platform-api/guides/miscellaneous#2-timestamps) format. The creation time of messages, channels, and users will be in-between the start_ts and end_ts.
   * @return startTs
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Specifies the starting timestamp of a period for target objects' creation date, in [Unix milliseconds](/docs/chat/v3/platform-api/guides/miscellaneous#2-timestamps) format. The creation time of messages, channels, and users will be in-between the start_ts and end_ts.")

  public Integer getStartTs() {
    return startTs;
  }


  public void setStartTs(Integer startTs) {
    this.startTs = startTs;
  }


  public RegisterAndScheduleDataExportData endTs(Integer endTs) {
    
    this.endTs = endTs;
    return this;
  }

   /**
   * Specifies the ending timestamp of a period for target objects&#39; creation date, in [Unix milliseconds](/docs/chat/v3/platform-api/guides/miscellaneous#2-timestamps) format. The creation time of messages, channels, and users will be in-between the start_ts and end_ts.
   * @return endTs
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Specifies the ending timestamp of a period for target objects' creation date, in [Unix milliseconds](/docs/chat/v3/platform-api/guides/miscellaneous#2-timestamps) format. The creation time of messages, channels, and users will be in-between the start_ts and end_ts.")

  public Integer getEndTs() {
    return endTs;
  }


  public void setEndTs(Integer endTs) {
    this.endTs = endTs;
  }


  public RegisterAndScheduleDataExportData format(String format) {
    
    this.format = format;
    return this;
  }

   /**
   * Specifies the format of the file to export the messages to. Acceptable values are json and csv. (Default: json)
   * @return format
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the format of the file to export the messages to. Acceptable values are json and csv. (Default: json)")

  public String getFormat() {
    return format;
  }


  public void setFormat(String format) {
    this.format = format;
  }


  public RegisterAndScheduleDataExportData csvDelimiter(String csvDelimiter) {
    
    this.csvDelimiter = csvDelimiter;
    return this;
  }

   /**
   * Sets a single character delimiter to separate the values in each row of the csv file which stores two-dimensional arrays of the exported message data. Either English alphabets or special characters can be used as a delimiter, including a horizontal tab (\\t), a line feed (\\n), a vertical bar (\\
   * @return csvDelimiter
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Sets a single character delimiter to separate the values in each row of the csv file which stores two-dimensional arrays of the exported message data. Either English alphabets or special characters can be used as a delimiter, including a horizontal tab (\\t), a line feed (\\n), a vertical bar (\\")

  public String getCsvDelimiter() {
    return csvDelimiter;
  }


  public void setCsvDelimiter(String csvDelimiter) {
    this.csvDelimiter = csvDelimiter;
  }


  public RegisterAndScheduleDataExportData timezone(String timezone) {
    
    this.timezone = timezone;
    return this;
  }

   /**
   * Specifies the timezone to be applied to the timestamp of the exported messages. For example, US/Pacific, Asia/Seoul, Europe/London, etc. (Default: UTC)
   * @return timezone
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the timezone to be applied to the timestamp of the exported messages. For example, US/Pacific, Asia/Seoul, Europe/London, etc. (Default: UTC)")

  public String getTimezone() {
    return timezone;
  }


  public void setTimezone(String timezone) {
    this.timezone = timezone;
  }


  public RegisterAndScheduleDataExportData senderIds(List<Integer> senderIds) {
    
    this.senderIds = senderIds;
    return this;
  }

  public RegisterAndScheduleDataExportData addSenderIdsItem(Integer senderIdsItem) {
    if (this.senderIds == null) {
      this.senderIds = new ArrayList<>();
    }
    this.senderIds.add(senderIdsItem);
    return this;
  }

   /**
   * Specifies an array of the IDs of the users which are used to filter the messages by its sender for the export. This property is effective only when the data_type parameter is set to messages, and can be specified up to 10 IDs in the request. (Default: all messages sent by any user)
   * @return senderIds
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies an array of the IDs of the users which are used to filter the messages by its sender for the export. This property is effective only when the data_type parameter is set to messages, and can be specified up to 10 IDs in the request. (Default: all messages sent by any user)")

  public List<Integer> getSenderIds() {
    return senderIds;
  }


  public void setSenderIds(List<Integer> senderIds) {
    this.senderIds = senderIds;
  }


  public RegisterAndScheduleDataExportData excludeSenderIds(List<Integer> excludeSenderIds) {
    
    this.excludeSenderIds = excludeSenderIds;
    return this;
  }

  public RegisterAndScheduleDataExportData addExcludeSenderIdsItem(Integer excludeSenderIdsItem) {
    if (this.excludeSenderIds == null) {
      this.excludeSenderIds = new ArrayList<>();
    }
    this.excludeSenderIds.add(excludeSenderIdsItem);
    return this;
  }

   /**
   * Specifies an array of the IDs of the users which are used to exclude their sent messages from the export. This property is effective only when the data_type parameter is set to messages, and can be specified up to 10 IDs. (Default: all messages sent by any user)
   * @return excludeSenderIds
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies an array of the IDs of the users which are used to exclude their sent messages from the export. This property is effective only when the data_type parameter is set to messages, and can be specified up to 10 IDs. (Default: all messages sent by any user)")

  public List<Integer> getExcludeSenderIds() {
    return excludeSenderIds;
  }


  public void setExcludeSenderIds(List<Integer> excludeSenderIds) {
    this.excludeSenderIds = excludeSenderIds;
  }


  public RegisterAndScheduleDataExportData channelUrls(List<String> channelUrls) {
    
    this.channelUrls = channelUrls;
    return this;
  }

  public RegisterAndScheduleDataExportData addChannelUrlsItem(String channelUrlsItem) {
    if (this.channelUrls == null) {
      this.channelUrls = new ArrayList<>();
    }
    this.channelUrls.add(channelUrlsItem);
    return this;
  }

   /**
   * Specifies an array of one or more URLs of channels to export the messages from. This property is effective only when the data_type parameter is set to messages or channels. (Default: all channels)
   * @return channelUrls
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies an array of one or more URLs of channels to export the messages from. This property is effective only when the data_type parameter is set to messages or channels. (Default: all channels)")

  public List<String> getChannelUrls() {
    return channelUrls;
  }


  public void setChannelUrls(List<String> channelUrls) {
    this.channelUrls = channelUrls;
  }


  public RegisterAndScheduleDataExportData excludeChannelUrls(List<String> excludeChannelUrls) {
    
    this.excludeChannelUrls = excludeChannelUrls;
    return this;
  }

  public RegisterAndScheduleDataExportData addExcludeChannelUrlsItem(String excludeChannelUrlsItem) {
    if (this.excludeChannelUrls == null) {
      this.excludeChannelUrls = new ArrayList<>();
    }
    this.excludeChannelUrls.add(excludeChannelUrlsItem);
    return this;
  }

   /**
   * Specifies an array of one or more URLs of channels to exclude when exporting the messages. This property is effective only when the data_type parameter is set to messages or channels. (Default: include all channels)
   * @return excludeChannelUrls
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies an array of one or more URLs of channels to exclude when exporting the messages. This property is effective only when the data_type parameter is set to messages or channels. (Default: include all channels)")

  public List<String> getExcludeChannelUrls() {
    return excludeChannelUrls;
  }


  public void setExcludeChannelUrls(List<String> excludeChannelUrls) {
    this.excludeChannelUrls = excludeChannelUrls;
  }


  public RegisterAndScheduleDataExportData userIds(List<Integer> userIds) {
    
    this.userIds = userIds;
    return this;
  }

  public RegisterAndScheduleDataExportData addUserIdsItem(Integer userIdsItem) {
    if (this.userIds == null) {
      this.userIds = new ArrayList<>();
    }
    this.userIds.add(userIdsItem);
    return this;
  }

   /**
   * Specifies an array of the IDs of the users to export their information. This property is effective only when the data_type parameter is set to users. (Default: all users)
   * @return userIds
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies an array of the IDs of the users to export their information. This property is effective only when the data_type parameter is set to users. (Default: all users)")

  public List<Integer> getUserIds() {
    return userIds;
  }


  public void setUserIds(List<Integer> userIds) {
    this.userIds = userIds;
  }


  public RegisterAndScheduleDataExportData showReadReceipt(Boolean showReadReceipt) {
    
    this.showReadReceipt = showReadReceipt;
    return this;
  }

   /**
   * Determines whether to include information about the read receipts of each channel in the exported data. The read receipt indicates the timestamps of when each user has last read the messages in the channel, in [Unix milliseconds](/docs/chat/v3/platform-api/guides/miscellaneous#2-timestamps). (Default: true)
   * @return showReadReceipt
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Determines whether to include information about the read receipts of each channel in the exported data. The read receipt indicates the timestamps of when each user has last read the messages in the channel, in [Unix milliseconds](/docs/chat/v3/platform-api/guides/miscellaneous#2-timestamps). (Default: true)")

  public Boolean getShowReadReceipt() {
    return showReadReceipt;
  }


  public void setShowReadReceipt(Boolean showReadReceipt) {
    this.showReadReceipt = showReadReceipt;
  }


  public RegisterAndScheduleDataExportData showChannelMetadata(Boolean showChannelMetadata) {
    
    this.showChannelMetadata = showChannelMetadata;
    return this;
  }

   /**
   * Determines whether to include [channel metadata](/docs/chat/v3/platform-api/guides/user-and-channel-metadata#2-view-a-channel-metadata) in the result files.
   * @return showChannelMetadata
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Determines whether to include [channel metadata](/docs/chat/v3/platform-api/guides/user-and-channel-metadata#2-view-a-channel-metadata) in the result files.")

  public Boolean getShowChannelMetadata() {
    return showChannelMetadata;
  }


  public void setShowChannelMetadata(Boolean showChannelMetadata) {
    this.showChannelMetadata = showChannelMetadata;
  }


  public RegisterAndScheduleDataExportData neighboringMessageLimit(Integer neighboringMessageLimit) {
    
    this.neighboringMessageLimit = neighboringMessageLimit;
    return this;
  }

   /**
   * Specifies the maximum number of other users&#39; messages to be exported, which took place after the specified message of a user filtered by the sender_ids property. Even if there may be more messages that took place, if the quantity exceeds the number of the neighboring_message_limit, they are omitted. Only the messages that took place right after the specified message will be counted and exported. This can be used to better analyze the context. Acceptable values are 1 to 10, inclusive. (Default: 0)
   * @return neighboringMessageLimit
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Specifies the maximum number of other users' messages to be exported, which took place after the specified message of a user filtered by the sender_ids property. Even if there may be more messages that took place, if the quantity exceeds the number of the neighboring_message_limit, they are omitted. Only the messages that took place right after the specified message will be counted and exported. This can be used to better analyze the context. Acceptable values are 1 to 10, inclusive. (Default: 0)")

  public Integer getNeighboringMessageLimit() {
    return neighboringMessageLimit;
  }


  public void setNeighboringMessageLimit(Integer neighboringMessageLimit) {
    this.neighboringMessageLimit = neighboringMessageLimit;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RegisterAndScheduleDataExportData registerAndScheduleDataExportData = (RegisterAndScheduleDataExportData) o;
    return Objects.equals(this.startTs, registerAndScheduleDataExportData.startTs) &&
        Objects.equals(this.endTs, registerAndScheduleDataExportData.endTs) &&
        Objects.equals(this.format, registerAndScheduleDataExportData.format) &&
        Objects.equals(this.csvDelimiter, registerAndScheduleDataExportData.csvDelimiter) &&
        Objects.equals(this.timezone, registerAndScheduleDataExportData.timezone) &&
        Objects.equals(this.senderIds, registerAndScheduleDataExportData.senderIds) &&
        Objects.equals(this.excludeSenderIds, registerAndScheduleDataExportData.excludeSenderIds) &&
        Objects.equals(this.channelUrls, registerAndScheduleDataExportData.channelUrls) &&
        Objects.equals(this.excludeChannelUrls, registerAndScheduleDataExportData.excludeChannelUrls) &&
        Objects.equals(this.userIds, registerAndScheduleDataExportData.userIds) &&
        Objects.equals(this.showReadReceipt, registerAndScheduleDataExportData.showReadReceipt) &&
        Objects.equals(this.showChannelMetadata, registerAndScheduleDataExportData.showChannelMetadata) &&
        Objects.equals(this.neighboringMessageLimit, registerAndScheduleDataExportData.neighboringMessageLimit);
  }

  @Override
  public int hashCode() {
    return Objects.hash(startTs, endTs, format, csvDelimiter, timezone, senderIds, excludeSenderIds, channelUrls, excludeChannelUrls, userIds, showReadReceipt, showChannelMetadata, neighboringMessageLimit);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RegisterAndScheduleDataExportData {\n");
    sb.append("    startTs: ").append(toIndentedString(startTs)).append("\n");
    sb.append("    endTs: ").append(toIndentedString(endTs)).append("\n");
    sb.append("    format: ").append(toIndentedString(format)).append("\n");
    sb.append("    csvDelimiter: ").append(toIndentedString(csvDelimiter)).append("\n");
    sb.append("    timezone: ").append(toIndentedString(timezone)).append("\n");
    sb.append("    senderIds: ").append(toIndentedString(senderIds)).append("\n");
    sb.append("    excludeSenderIds: ").append(toIndentedString(excludeSenderIds)).append("\n");
    sb.append("    channelUrls: ").append(toIndentedString(channelUrls)).append("\n");
    sb.append("    excludeChannelUrls: ").append(toIndentedString(excludeChannelUrls)).append("\n");
    sb.append("    userIds: ").append(toIndentedString(userIds)).append("\n");
    sb.append("    showReadReceipt: ").append(toIndentedString(showReadReceipt)).append("\n");
    sb.append("    showChannelMetadata: ").append(toIndentedString(showChannelMetadata)).append("\n");
    sb.append("    neighboringMessageLimit: ").append(toIndentedString(neighboringMessageLimit)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("start_ts");
    openapiFields.add("end_ts");
    openapiFields.add("format");
    openapiFields.add("csv_delimiter");
    openapiFields.add("timezone");
    openapiFields.add("sender_ids");
    openapiFields.add("exclude_sender_ids");
    openapiFields.add("channel_urls");
    openapiFields.add("exclude_channel_urls");
    openapiFields.add("user_ids");
    openapiFields.add("show_read_receipt");
    openapiFields.add("show_channel_metadata");
    openapiFields.add("neighboring_message_limit");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("start_ts");
    openapiRequiredFields.add("end_ts");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to RegisterAndScheduleDataExportData
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (RegisterAndScheduleDataExportData.openapiRequiredFields.isEmpty()) {
          return;
        } else { // has required fields
          throw new IllegalArgumentException(String.format("The required field(s) %s in RegisterAndScheduleDataExportData is not found in the empty JSON string", RegisterAndScheduleDataExportData.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!RegisterAndScheduleDataExportData.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `RegisterAndScheduleDataExportData` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : RegisterAndScheduleDataExportData.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (jsonObj.get("format") != null && !jsonObj.get("format").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `format` to be a primitive type in the JSON string but got `%s`", jsonObj.get("format").toString()));
      }
      if (jsonObj.get("csv_delimiter") != null && !jsonObj.get("csv_delimiter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `csv_delimiter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("csv_delimiter").toString()));
      }
      if (jsonObj.get("timezone") != null && !jsonObj.get("timezone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timezone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timezone").toString()));
      }
      // ensure the json data is an array
      if (jsonObj.get("sender_ids") != null && !jsonObj.get("sender_ids").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `sender_ids` to be an array in the JSON string but got `%s`", jsonObj.get("sender_ids").toString()));
      }
      // ensure the json data is an array
      if (jsonObj.get("exclude_sender_ids") != null && !jsonObj.get("exclude_sender_ids").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `exclude_sender_ids` to be an array in the JSON string but got `%s`", jsonObj.get("exclude_sender_ids").toString()));
      }
      // ensure the json data is an array
      if (jsonObj.get("channel_urls") != null && !jsonObj.get("channel_urls").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `channel_urls` to be an array in the JSON string but got `%s`", jsonObj.get("channel_urls").toString()));
      }
      // ensure the json data is an array
      if (jsonObj.get("exclude_channel_urls") != null && !jsonObj.get("exclude_channel_urls").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `exclude_channel_urls` to be an array in the JSON string but got `%s`", jsonObj.get("exclude_channel_urls").toString()));
      }
      // ensure the json data is an array
      if (jsonObj.get("user_ids") != null && !jsonObj.get("user_ids").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `user_ids` to be an array in the JSON string but got `%s`", jsonObj.get("user_ids").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!RegisterAndScheduleDataExportData.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'RegisterAndScheduleDataExportData' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<RegisterAndScheduleDataExportData> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(RegisterAndScheduleDataExportData.class));

       return (TypeAdapter<T>) new TypeAdapter<RegisterAndScheduleDataExportData>() {
           @Override
           public void write(JsonWriter out, RegisterAndScheduleDataExportData value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public RegisterAndScheduleDataExportData read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of RegisterAndScheduleDataExportData given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of RegisterAndScheduleDataExportData
  * @throws IOException if the JSON string is invalid with respect to RegisterAndScheduleDataExportData
  */
  public static RegisterAndScheduleDataExportData fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, RegisterAndScheduleDataExportData.class);
  }

 /**
  * Convert an instance of RegisterAndScheduleDataExportData to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

